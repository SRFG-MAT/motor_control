#!/usr/bin/env python
# coding:   latin-1
# Autor:    Ingmar Stapel
# Datum:    2020-02-02
# Version:  1.0
# Language:	English
# Homepage: http://custom-build-robots.com

# This program was developed to control the left and right motors 
# of the robot car. It is based on the assumption that a L298N 
# H-bridge is used as motor driver. The PWM signal for controlling 
# the rotational speed of the motors is generated by an Adafruit 
# PCA9685 servo controller.

# This program must be called by a higher-level program which takes 
# over the control of the program L298NHBridgePCA9685.

# The class RPi.GPIO is imported, which enables the control of the 
# GPIO pins of the Raspberry Pi.

from __future__ import division
import RPi.GPIO as io
io.setmode(io.BCM)

import time

# Import the Adafruit PCA9685 library for the servo controller
import Adafruit_PCA9685

# Initialise the PCA9685 using the default address (0x40).
PCA9685_pwm = Adafruit_PCA9685.PCA9685()

# Here the frequency of the PWM signal is set. I made good experiences 
# with 60Hz for the L298N H-Bridge. Also most servo motors work with 60Hz.
PCA9685_pwm.set_pwm_freq(60)

# The variable duty_cycle specifies the maximum duty cycle of the motors 
# per 100 Herts. For the speed of the motors the duty cycle always starts 
# at 0 and ends at a value of 4095 ]0, 4095[.
duty_cycle = 4095

# The following call deactivates any warnings issued by the class RPi.GPIO.
io.setwarnings(False)

# In the following program section the logical cabling of the Raspberry Pi 
# is shown in the program. The pins IN1 to IN4, known from the motor driver,
# are assigned the GPIO addresses.

# --- START CONFIGURATION GPIO addresses ---
IN1 = 6
IN2 = 13
IN3 = 19
IN4 = 26
# --- END CONFIGURATION GPIO addresses ---

# ENA and ENB of the L298N H-bridge are connected to channel 0 and 1 
# of the servo controller
# ENA = Channel 0
# ENB = Channel 1

# The variable leftmotor_in1_pin gets the variable IN1 assigned. 
# The variable leftmotor_in1_pin gets the variable IN2 assigned. 
leftmotor_in1_pin = IN1
leftmotor_in2_pin = IN2

# Both variables leftmotor_in1_pin and leftmotor_in2_pin are 
# defined as outputs "OUT". With those variables the spinning  
# direction of the motores is set.
io.setup(leftmotor_in1_pin, io.OUT)
io.setup(leftmotor_in2_pin, io.OUT)

# The variable leftmotor_in1_pin gets the variable IN3 assigned. 
# The variable leftmotor_in1_pin gets the variable IN4 assigned.  
rightmotor_in1_pin = IN3
rightmotor_in2_pin = IN4

# Both variables rightmotor_in1_pin and rightmotor_in2_pin are 
# defined as outputs "OUT". With those variables the spinning  
# direction of the motores is set.
io.setup(rightmotor_in1_pin, io.OUT)
io.setup(rightmotor_in2_pin, io.OUT)

# The GPIO pins of the Raspberry Pi are initially set to False. 
# This ensures that no HIGH signal is present and that the motor 
# driver is not activated unintentionally.
io.output(leftmotor_in1_pin, False)
io.output(leftmotor_in2_pin, False)
io.output(rightmotor_in1_pin, False)
io.output(rightmotor_in2_pin, False)

# The function setMotorMode(motor, mode) defines the direction of 
# rotation of the motors. The function has two input variables the
# variable motor and mode.
# motor      -> defines if the left or right motor is called
# mode       -> defines the operating mode like forward stopp or 
#               reverse
# Example:
# setMotorMode(leftmotor, forward)  The left motor is spinning 
#                                   forwared
# setMotorMode(rightmotor, reverse) The right motor is spinning 
#                                   backwards
# setMotorMode(rightmotor, stopp)   The right motor is stopped 

def setMotorMode(motor, mode):
   if motor == "leftmotor":
      if mode == "reverse":
         io.output(leftmotor_in1_pin, True)
         io.output(leftmotor_in2_pin, False)
      elif  mode == "forward":
         io.output(leftmotor_in1_pin, False)
         io.output(leftmotor_in2_pin, True)
      else:
         io.output(leftmotor_in1_pin, False)
         io.output(leftmotor_in2_pin, False)
   elif motor == "rightmotor":
      if mode == "reverse":
         io.output(rightmotor_in1_pin, False)
         io.output(rightmotor_in2_pin, True)      
      elif  mode == "forward":
         io.output(rightmotor_in1_pin, True)
         io.output(rightmotor_in2_pin, False)
      else:
         io.output(rightmotor_in1_pin, False)
         io.output(rightmotor_in2_pin, False)
   else:
      io.output(leftmotor_in1_pin, False)
      io.output(leftmotor_in2_pin, False)
      io.output(rightmotor_in1_pin, False)
      io.output(rightmotor_in2_pin, False)

# The function setMotorLeft(power) sets the speed of the left 
# motors. The speed is transferred as a value between -1 and 1.
# If the value is negative, the motors should turn backwards,
# otherwise forward. Next the rotating speed for the PWM signale
# is calculaed from the input values transferred.

# Example:
# The speed is set by +1 (max) und -1 (min).
# The example explains how the rotating speed of the motors is 
# calcualed.
# SetMotorLeft(0)     -> the left motor is stopped
# SetMotorLeft(0.75)  -> the left motors turns forward with a  
#                        speed of 0.75 multiplied with DC_MAX
# SetMotorLeft(-0.5)  -> the left motors turns backwards with a  
#                        speed of -0.5 multiplied with DC_MAX 
# SetMotorLeft(1)     -> the left motor turns at maximum speed 
#                        multiplied with DC_MAX
def setMotorLeft(power):
   int(power)
   if power < 0:
      # reverse mode for the left motor
      setMotorMode("leftmotor", "reverse")
      pwm = -int(duty_cycle * power)
      if pwm > duty_cycle:
         pwm = duty_cycle
   elif power > 0:
      # forward mode for the left motor
      setMotorMode("leftmotor", "forward")
      pwm = int(duty_cycle * power)
      if pwm > duty_cycle:
         pwm = duty_cycle
   else:
      # the left motor is stopped
      setMotorMode("leftmotor", "stopp")
      pwm = 0
   PCA9685_pwm.set_pwm(0, 0, pwm)

# The function setMotorRight(power) sets the speed of the right 
# motors. The speed is transferred as a value between -1 and 1.
# If the value is negative, the motors should turn backwards,
# otherwise forward. Next the rotating speed for the PWM signale
# is calculaed from the input values transferred.

# Example:
# The speed is set by +1 (max) und -1 (min).
# The example explains how the rotating speed of the motors is 
# calcualed.
# setMotorRight(0)     -> the right motor is stopped
# setMotorRight(0.75)  -> the right motors turns forward with a  
#                        speed of 0.75 multiplied with DC_MAX
# setMotorRight(-0.5)  -> the right motors turns backwards with a  
#                        speed of -0.5 multiplied with DC_MAX 
# setMotorRight(1)     -> the right motor turns at maximum speed 
#                        multiplied with DC_MAX
def setMotorRight(power):
   int(power)
   if power < 0:
      # reverse mode for the right motor
      setMotorMode("rightmotor", "reverse")
      pwm = -int(duty_cycle * power)
      if pwm > duty_cycle:
         pwm = duty_cycle
   elif power > 0:
      # forward mode for the right motor
      setMotorMode("rightmotor", "forward")
      pwm = int(duty_cycle * power)
      if pwm > duty_cycle:
         pwm = duty_cycle
   else:
      # the right motor is stopped
      setMotorMode("rightmotor", "stopp")
      pwm = 0
   PCA9685_pwm.set_pwm(1, 0, pwm)

# The exit() function sets the outputs that control the motor driver
# to False. Thus, after calling the function, the motor driver is 
# in a safe state and the motors are stopped.
def exit():
   io.output(leftmotor_in1_pin, False)
   io.output(leftmotor_in2_pin, False)
   io.output(rightmotor_in1_pin, False)
   io.output(rightmotor_in2_pin, False)
   io.cleanup()
   
# End of the program